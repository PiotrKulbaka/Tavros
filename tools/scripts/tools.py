from concurrent.futures.thread import ThreadPoolExecutor
from pathlib import Path
from .config import Config
from .variable_resolver import VariableResolver
from .builtin_variables import get_builtin_variables
from .utils import run_command

def collect_files_by_exts(base_dir, exts):
    """
    Collect all files with the specified extensions from the given directory
    and its subdirectories.

    :param base_dir: The base directory to start searching.
    :param exts: List of file extensions to be collected.
    :return: A sorted list of Path objects representing the collected files.
    """
    collected_files = []

    def has_suffix(path, suffixes):
        for suffix in suffixes:
            if str(path).endswith(suffix):
                return True
        return False

    def recursive_collect(dir):
        for entry in Path(dir).iterdir():
            if entry.is_file() and has_suffix(entry, exts):
                collected_files.append(entry)
            elif entry.is_dir():
                recursive_collect(entry)

    recursive_collect(base_dir)
    return sorted(collected_files, key=lambda path: (path.parent, path))


def setup(root_dir, initial_config_path):
    """
    Initialize the project by generating an 'env.toml' file with configuration.

    :param root_dir: The root directory of the project.
    :param initial_config_path: The path to the initial configuration file.
    """
    env_file_path = Path(root_dir) / 'env.toml'
    cfg = Config(initial_config_path)
    builtin_vars = get_builtin_variables(root_dir)
    resolver = VariableResolver()
    resolver.resolve_for_config(cfg, builtin_vars)
    cfg.save(env_file_path)
    print("Project has been successfully initialized")
    print(f"Created env.toml: `{env_file_path}`")


def autoformat(cfg: Config):
    """
    Format all source code files using clang-format.

    :param cfg: Config object with the project configuration.
    """
    exts = cfg.command.autoformat.for_exts
    clang_foramt_tool_path = cfg.command.autoformat.clang_format_tool_path
    style_param = f"--style=file:{str(cfg.command.autoformat.style_file)}"

    files = []
    for p in cfg.command.autoformat.paths:
        files.extend(collect_files_by_exts(p, exts))

    def apply_clang_format(path):
        run_command([clang_foramt_tool_path, style_param, '-i', str(path)])

    with ThreadPoolExecutor(max_workers=8) as executor:
        for f in files:
            executor.submit(apply_clang_format, f)


def collect_sources(cfg: Config):
    """
    Collect source code files from the specified directories and generate
    'CMakeSources.txt' files for each of them.

    :param cfg: Config object with the project configuration.
    """
    exts = cfg.command.collect_sources.for_exts
    test_exts = cfg.command.collect_sources.for_test_exts

    def collect_lib_sources(lib_dir, lib_name):
        """
        Collect source code files from the specified directory and generate
        'CMakeSources.txt' file for it.

        :param lib_dir: Directory containing source code files.
        :param lib_name: Library name for the generated 'CMakeSources.txt' file.
        """
        sources = collect_files_by_exts(lib_dir, exts)
        test_sources = collect_files_by_exts(lib_dir, test_exts)

        # Exclude test sources from sources
        sources = [s for s in sources if s not in test_sources]

        if not sources and not test_sources:
            return

        cmake_sources_filename = lib_dir / 'CMakeSources.txt'

        print(f'Sources: `{cmake_sources_filename}`')

        with open(cmake_sources_filename, 'w') as f:
            def print_sources_list(sources):
                prev = None
                for s in sources:
                    if prev and prev.parent != s.parent:
                        f.write('\n')
                    f.write(f'    ${{CMAKE_CURRENT_LIST_DIR}}/{s.relative_to(lib_dir)}\n')
                    prev = s

            f.write('#\n# Autogenerated file, do not edit manually\n')
            f.write('# Use `./tavros.py collect_sources` for regenerate it file\n#\n\n')

            if sources:
                f.write(f'set(TAV_{lib_name.upper()}_SOURCES\n')
                print_sources_list(sources)
                f.write(')\n')
            
            if test_sources:
                f.write(f'\nset(TAV_{lib_name.upper()}_TEST_SOURCES\n')
                print_sources_list(test_sources)
                f.write(')\n')

    paths = cfg.command.collect_sources.paths
    for p in paths:
        dir = Path(p)
        if dir.exists():
            collect_lib_sources(dir, dir.name)
        else:
            print(f'Directory is not exists: {str(dir)}')
